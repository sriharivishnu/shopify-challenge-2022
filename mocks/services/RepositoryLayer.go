// Code generated by mockery 2.9.2. DO NOT EDIT.

package mocks

import (
	models "github.com/sriharivishnu/shopify-challenge/models"
	mock "github.com/stretchr/testify/mock"
)

// RepositoryLayer is an autogenerated mock type for the RepositoryLayer type
type RepositoryLayer struct {
	mock.Mock
}

// Create provides a mock function with given fields: name, description, ownerId
func (_m *RepositoryLayer) Create(name string, description string, ownerId string) (models.Repository, error) {
	ret := _m.Called(name, description, ownerId)

	var r0 models.Repository
	if rf, ok := ret.Get(0).(func(string, string, string) models.Repository); ok {
		r0 = rf(name, description, ownerId)
	} else {
		r0 = ret.Get(0).(models.Repository)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(name, description, ownerId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoriesForUser provides a mock function with given fields: ownerId
func (_m *RepositoryLayer) GetRepositoriesForUser(ownerId string) ([]models.Repository, error) {
	ret := _m.Called(ownerId)

	var r0 []models.Repository
	if rf, ok := ret.Get(0).(func(string) []models.Repository); ok {
		r0 = rf(ownerId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(ownerId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositoryByName provides a mock function with given fields: username, reponame
func (_m *RepositoryLayer) GetRepositoryByName(username string, reponame string) (models.Repository, error) {
	ret := _m.Called(username, reponame)

	var r0 models.Repository
	if rf, ok := ret.Get(0).(func(string, string) models.Repository); ok {
		r0 = rf(username, reponame)
	} else {
		r0 = ret.Get(0).(models.Repository)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(username, reponame)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Search provides a mock function with given fields: query, limit, offset
func (_m *RepositoryLayer) Search(query string, limit int, offset int) ([]models.SearchResult, error) {
	ret := _m.Called(query, limit, offset)

	var r0 []models.SearchResult
	if rf, ok := ret.Get(0).(func(string, int, int) []models.SearchResult); ok {
		r0 = rf(query, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SearchResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int) error); ok {
		r1 = rf(query, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
